# *****************************************************************************
# *
# *  This Python script is a part of tha analysis of the data published in 
# *  the paper: "Universal motion patterns in confluent cell monolayers"
# *  by Silke Henkes, Kaja Kostanjevec, J. Martin Collinson, Rastko Sknepnek, 
# *  and Eric Bertin, Jounral name, vol, page (2019).
# *
# *  Please refer to the document Computational_summary.pdf for a detailed
# *  description of the tasks performed by this script.
# * 
# *****************************************************************************


# All runtime messages will be sent to file messages.msg
messages messages.msg
config configuration {type = json}

# box is cubic with size 200x200x10 
box fixed { lx = 200.0;  ly = 200.0;  lz = 10.0 }

# We read in particle positions 
# This is for now our spherical relaxed initial configuration
input vertex_input.dat

# Read boundary connectivity
# form of the file. 
# # comments/headers
# edge_id particle_id_1 particle_id_2
# Boundary of the spherical initial relaxed configuration
read_cell_boundary vertex_bound.dat

# neighbourlist. The static_boundary flag prevents new boundary particles from being added to the system, use for fixed boundaries.
# max_perimeter and max_edge_len refer to the triangulation faces and edges. They are important parameters and often set the step at which the simulation will fail.
#
# Add new boundary particles when appropriate
nlist { rcut = 2.4; pad = 0.5; build_faces; max_perimeter = 30.0; max_edge_len = 20.0; triangulation; }

# We constrain all particles to move only on the xy plane.
constraint plane { unlimited  }

# Cell potential
# K is the area term stiffness, gamma is the perimeter stiffness 
# lambda is the junction tension
pair_potential vp { K = @KVAL; gamma = @GAMMA; lambda = @LAMBDA }


# line tension only applies to the particles that are on the boundary
# The 2.0 here is the equilibrium value of the line - no tension if the boundary stays that way
pair_potential line_tension { lambda = @LINE; l0 = 0.0 }
pair_potential boundary_bending { kappa = 0.5; }

# Soft repulsion  
# radius of 1.0 is quite high here and may not be necessary for shape index < 4.0 (roughly)
# I prefer to use 0.5 for most cases.
pair_potential soft { k = 10.0; a = 0.5 }


# frequent logging of simple metrics
log cell.log { freq = 1000; size; area; avg_perim; vp_energy }

# .vtp dumps
dump cell { type=vtp; start=0; freq=1000; multi; include_mesh }
dump cell_dual { type=vtp; start=0; freq=1000; multi; dual }
# text dumps
dump cell { type=full; start=0; freq=1000; multi; id; tp; boundary; coordinate; velocity; director; cell_area; cell_perim; keys }

# IMPORTANT. Adding the activity to the non-boundary particles only. Alpha is v0. Then v0 in the integrator should be set to 0.
external self_propulsion { alpha = @V0; exclude_boundary; } 

# Running the simulation
timestep 0.01

# IMPORTANT. v0 is set to 0. in the integrator. We use 'external self_propulsion {}' command to add activity.
# 'Boundary' and 'Internal' groups automatically created 
# Open boundaries
integrator brownian {group= all; seed = @SEED;  nu = @NU; mu = 1.0;  v0 = 0.0 }

run @TRUN



