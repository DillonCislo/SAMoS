# *****************************************************************************
# *
# *  This Python script is a part of tha analysis of the data published in 
# *  the paper: "Universal motion patterns in confluent cell monolayers"
# *  by Silke Henkes, Kaja Kostanjevec, J. Martin Collinson, Rastko Sknepnek, 
# *  and Eric Bertin, Jounral name, vol, page (2019).
# *
# *  Please refer to the document Computational_summary.pdf for a detailed
# *  description of the tasks performed by this script.
# * 
# *****************************************************************************

#
#  Simulation of N=3183 active particles interacting with the 
#  soft-core potential confined on the surface of the xy plane
#  We also allow for cell division using population contol 
#  based on density.
#  


# All runtime messages will be sent to file messages.msg
messages messages.msg

# Every simulation requires a box
# "periodic" means that periodic boundary are applied.
box periodic { lx = 867.0;  ly = 662.0;  lz = 50.0 }

# We read in particle positions from file plane.dat (generated by tools in utils directory)
input plane.txt

# The particles are divided into three groups: group 1 is normally dividing, group 2 are immortal tracers which are otherwise identical
group g1 { type = 1 }
group g2 { type = 2 }


# We set the neighbour list with cutoff distance 2.4 and padding distance of 0.5
nlist { rcut = 25; pad = 2.5 }


# We constrain all particles to move only on the xy plane with lx=100, ly = 100 (actually those are read from the box)
constraint plane { lx = 867; ly = 662 }


# All particles are interacting with the soft-core potential of strength 
pair_potential soft_attractive {k=@KVAL; re_fact = 1.15; use_particle_radii; phase_in=linear; min_val=0.0; max_val=1.0}

# We would also like to monitor measure a few quantities
# Here we define a log that keeps track of step, velocity, soft core potenetial energy, and alignment 
# These quantities will be logged once every 1000 steps
# Note that step is always logged automatically
log plane_test.log { freq = 1000; velocity; soft_attractive_energy }


# Now we are at the point to execute actual simulations. 
# We switch the integrator to brownian.
# Integrate equations of motion using Brownian dynamics.
# seed is the initial seed for the random number generator
# dt is the integrator time step (in Lennard-Jones units) 
# nu sets the width of the distribution for random changes of velocity
# mu is particle mobility
# v0 is the intensity of the self-propelling velocity
timestep 0.001

external self_propulsion { alpha = @V0} 
integrator brownian_pos { group = all; dt=0.001; seed = 1;  mu = 1.0; }
integrator brownian_align { group = all; dt=0.001; seed = 1;  nu = @NUVAL; mur = 1.0;}

population density { group = g1; division_rate = @DIV; seed = @SEED;  split_distance=0.01; rho_max = 6.0; death_rate = @DEATH; new_r = 11.0; poly = 0.3; freq = 50; old_group = g1; new_group = g1  }

dump cornea_cells { type=full; start=0; freq=@FREQ; multi; id;  flag; tp; radius; coordinate; velocity; header}
dump cornea_cells { type=vtp; start=0; freq=@FREQ; multi}

run @TRUN



